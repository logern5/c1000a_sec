# Actiontec C1000A DSL CenturyLink router Authentication Bypass vulnerability

**Vendor**: Actiontec

**Product**: C1000A

**Firmware Version**: CAC004-31.30L.95

## High level overview:
A remote attacker can change system settings using the HTTP configuration interface of the Actiontec C1000A router without authentication. An attacker can change 
various configuration settings on the router, such as enabling the router's Telnet server and set a Telnet password with this vulnerability, gaining root shell access 
to the device.

## Product information:
CenturyLink branded Actiontec C1000A router running firmware version CAC004-31.30L.95 (the latest firmware version as of December 5, 2020).

## Root cause analysis:
The authentication for the web interface on the C1000A has two parts: the session key and the session ID. The session key is a key randomly generated by the server and 
is only good for one action (a sort of CSRF key). The key is written into the JavaScript code of each web page served by the router's HTTP server. The second part of 
authentication is the session ID. The session ID is an ID set by the client randomly. To authenticate, the client sends a username and base64 encoded password along with 
a session key and a session ID like so:

```
POST /login.cgi HTTP/1.1

adminUserName=admin&adminPassword=YWRtaW4%3D&sessionKey=1809317030&sessionId=1234&nothankyou=1
```

Once the client authenticates, the HTTP server registers the clients session ID and sends back a Set-Cookie header with that session ID. Whenever the client visits a 
router configuration page (such as /advancedsetup_firewallsettings.html), the server will check the session ID cookie, and if the cookie is valid, will let the client 
access the page. However, many of the CGI scripts which are built in to the HTTP server do not check the session ID, but only the session key and if a valid session ID 
is active (an administrator is logged in somewhere), and this is where the flaw is. Any unauthenticated user can get a session key from the server by sending a GET 
request to /login.html, and thus are able to change router settings. For example, an unauthenticated attacker can send a POST request to /advancedsetup_remotetelnet.cgi 
to set the Telnet password with only a session key as authentication:

```
POST /advancedsetup_remotetelnet.cgi HTTP/1.1

serCtlTelnet=3&remTelUser=admin&remTelTimeout=300&remTelPassChanged=1&nothankyou=0&remTelPass=dXQzYlA3bWM%3D&sessionKey=559592963
```

Decompiling the /bin/httpd binary from the router, many CGI pages rely on the function cgiValidateSessionKey() to determine if a CGI request is valid. For example, the 
function do_wl_cgi(), which handles CGI requests to change wireless LAN settings, contains this code to validate the request:

```
  iVar1 = cgiValidateSessionKey(param_2);
  if (iVar1 != 0) {
    return;
  }
```

No mention of the session ID exists in the function anywhere. The function cgiValidateSessionKey() simply checks if the session key supplied by the client matches the 
one generated by the server.

To fix this issue, in the CGI handling code, a check against the session ID needs to be added in addition to the existing session key check. There is already a function 
in the code which validates the session ID, AEI_validateSessionID().

## Proof of concept:
[This](poc/auth_bypass.sh) proof of concept written in bash enables the telnet daemon on the router and sets the telnet password to 'admin'
